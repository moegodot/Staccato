# AGENTS.md of project "Staccato"

## Dev environment tips
- Use `./bootstrap.sh` to install building tool `sb`
- Use `sb build-[XXXX]` to build some part, there are four part: `rust`,`glue`,`managed` and `all`. e.g. `sb build-rust`.
- Use `sb update-version` to update version in Cargo.toml and Directory.Build.props. Keep version updated when commit.

## Project Information

---

## 0. 导言：Staccato 的核心愿景
**Staccato（断奏）** 是一款基于 Rust 与 .NET (C#) 深度融合的现代化游戏引擎。其命名取自音乐术语，寓意引擎架构的“短促有力、响应灵敏、模块解耦”。本引擎旨在解决高性能原生层（Rust）与高效逻辑层（C#）之间的协作难题，为开发者提供一个既能压榨硬件极限，又能享受极高开发效率的 2D/3D 模拟平台。

本方案旨在记录 Staccato 在研发初期的核心架构决策、系统分层逻辑以及跨语言协作的避坑准则。

---

## 第一部分：分层架构与模块拓扑

Staccato 拒绝“全家桶”式的臃肿设计，采用 **“骨架与灵魂”** 的混合驱动模式：Rust 作为宿主提供高性能底座，.NET 作为逻辑单元驱动业务。

### 1.1 模块分发策略 (Crate Partitioning)
为了实现高度的解耦与 CI 效率，项目采用 Rust Workspace 进行物理隔离：
1.  **staccato-core (原子层)**：仅包含数学原语（Rect, Point, Color）。该层级要求**零依赖**，确保其稳定性和极致的编译速度。它是所有模块的地基。
2.  **staccato-shared (契约层)**：定义引擎的全局错误处理协议（基于 Result 别名）、基础常量和跨模块的共识。
3.  **staccato-platform-api (接口层)**：定义“环境”的抽象，包括窗口后端（WindowBackend）、输入接口、计时器等。它不包含实现，只定义协议。
4.  **staccato-render-api (渲染协议层)**：定义“如何描述画面”。它将渲染指令与具体的图形后端（wgpu/Vulkan）隔离，为 Headless 模式和单元测试提供可能。
5.  **staccato-hal (硬件抽象实现层)**：基于 **SDL3**。负责将操作系统的原始信号转化为引擎的标准 API。这是对平台相关性最强的模块。
6.  **staccato-render-wgpu (渲染实现层)**：基于 **wgpu**。负责将渲染协议转化为 GPU 指令，管理纹理、着色器和管线。
7.  **staccato-engine (聚合层)**：将上述模块进行逻辑粘合，驱动主循环（Update/FixedUpdate/Render）。
8.  **staccato-dotnet (网关层)**：负责 FFI 导出，是 Rust 与 C# 之间的“海关”。

### 1.2 核心设计哲学
*   **API 契约化**：模块间不直接依赖实现，而是依赖抽象接口。这允许我们在不改动逻辑层的情况下，随时更换底层驱动（例如从 SDL3 迁移到 winit）。
*   **状态与副作用分离**：读取属性（如 Window Size）应当是零开销且不失败的（Infallible）；改变状态（如 Resize）则是具有副作用且可能失败的（Fallible）。

---

## 第二部分：窗口与图形系统架构

窗口是引擎与用户交互的第一道防线，其稳定性和性能至关重要。

### 2.1 SDL3 与 wgpu 的深度解耦
Staccato 采用了 **“句柄分离”** 模式：
*   **实体窗口 (Window Object)**：由 `staccato-hal` 管理。它是非线程安全的，只能在主线程（Thread 0）操作。它持有 SDL 的原始指针，负责处理标题、位置、尺寸等 UI 逻辑。
*   **渲染句柄 (Window Handle)**：这是一个轻量级的、**可拷贝 (Copy)**、**线程安全 (Send/Sync)** 的数据结构。它只包含创建 GPU Surface 所需的原始 ID。
*   **架构收益**：渲染器（Renderer）只需要持有这个轻量句柄，而不需要关心窗口是否存在。这使得渲染工作可以在独立的线程中安全地进行，而不会违反操作系统的 UI 线程限制。

### 2.2 渲染表面的生命周期管理
在处理窗口关闭与销毁时，Staccato 遵循严格的顺序：**Surface 先死，Window 后死。**
为避免 Rust 的借用检查器导致的“自引用结构体”难题，我们采用 `ManuallyDrop` 或 `Option` 进行显式销毁控制。这确保了在窗口句柄失效前，GPU 的交换链已经安全释放，从根源上杜绝了驱动级别的闪退。

---

## 第三部分：主循环与时间管理

主循环是引擎的心跳。Staccato 追求物理模拟的确定性与视觉表现的平滑性。

### 3.1 累加器物理步进 (Fixed Timestep)
为了保证物理模拟不随帧率波动，Staccato 强制执行 **“时间银行（Accumulator）”算法**：
*   **逻辑更新 (Update)**：随帧率波动，处理 UI 和视觉效果。
*   **物理更新 (FixedUpdate)**：采用固定步长。当主循环累计的时间足够支付一个“步长”时，连续执行物理更新，直到清空余额。
*   **安全性**：引入“死亡螺旋”保护上限。如果一帧卡顿时间过长，物理更新不会尝试无限追赶，而是丢弃过时的时间，保证程序不卡死。

### 3.2 高精度时间戳
Staccato 全盘信任 **SDL3 的纳秒级时钟 (SDL_GetTicksNS)**。
所有的事件（键盘、鼠标、系统消息）在产生的瞬间都会被打上 SDL 的原始时间戳。这允许逻辑层在处理输入时，能够计算出精确的“输入延迟”，并实现跨帧的平滑插值，这对于高精度模拟（如音乐游戏或赛车游戏）至关重要。

---

## 第四部分：事件系统与遥测

### 4.1 批处理事件泵
Staccato 放弃了“一个事件一个回调”的陈旧模式，采用 **“命令缓冲区（Command Buffer）”**：
1.  在每一帧的开始，Rust 批量收集所有系统事件，存入一个连续内存的缓冲区。
2.  通过一次 FFI 调用，将整个缓冲区暴露给 C#。
3.  C# 侧像收割机一样遍历连续内存，最大化 CPU 缓存命中率。

### 4.2 统一遥测架构
引擎不创建封闭的日志 API，而是全面拥抱 Rust 的 **`tracing`** 生态。
*   **跨语言日志**：建立 FFI 桥接，使 C# 产生的日志能够流入 Rust 的 `tracing` 管道，实现统一的格式化、过滤和文件存储。
*   **性能可视化**：在开发模式下，通过集成支持 OpenTelemetry 的工具（如 Tracy），实现对每一帧“逻辑-物理-渲染”耗时的动态可视化监控。

---

## 第五部分：错误处理哲学

为了兼顾 Rust 的严谨性与 C# 的易用性，Staccato 实施了多层级的错误治理方案：

1.  **内部精细化 (Low-level)**：在驱动层使用强类型枚举，区分可恢复错误（如分辨率不支持）和致命错误（如驱动崩溃）。
2.  **外部高效化 (High-level)**：引入高性能错误库（如 `rancor`），优化“成功路径”的内存开销，确保高频调用的 API（如 Update）在没有错误发生时拥有接近零的开销。
3.  **FFI 转换层**：在 Rust 边界处将复杂的 Error 对象转化为“错误码 + 详细描述字符串”，C# 侧接收后根据错误码抛出对应的托管异常。

---

## 第六部分：关键注意点与避坑指南 (ARCHIVE NOTES)

在未来的维护与扩展中，必须坚守以下红线：

1.  **主线程亲和性**：SDL_PollEvent 和任何涉及窗口创建/修改的操作**绝对禁止**离开 Thread 0。在 macOS 上违背此条会导致直接闪退。
2.  **避免自引用地牢**：在定义包含 Window 和 Surface 的结构体时，确保 Surface 使用的是“拥有所有权”的句柄或静态句柄，否则生命周期标注将使代码无法扩展。
3.  **零分配主循环**：主循环内（尤其是 Update/Render）绝对禁止发生每帧一次的内存分配。任何缓冲区（事件队列、顶点数据）都必须预分配并重用。
4.  **FFI 零拷贝原则**：尽量通过 `repr(C)` 结构体直接在内存中共享数据（如窗口状态），避免频繁的字符串拷贝或复杂的对象序列化。
5.  **Headless 优先**：任何系统组件在设计时，都必须考虑在没有窗口（SDL_VIDEODRIVER=dummy）的环境下如何运行。这不仅是为了服务器，更是为了单元测试。

---

## 7. 结语
Staccato 引擎的设计目标不是做一个“大而全”的游戏工厂，而是做一个 **“极度精准、高度可控”** 的精密仪器。通过 Rust 提供的内存安全与多线程优势，结合 .NET 带来的开发便捷性，Staccato 正在开辟一条属于自己的道路。

**归档确认：Staccato 引擎 1.0 架构方案。**
**状态：方案锁定，进入核心模块迭代期。**

